diff -uNr linux-6.1.97.orig/drivers/net/wireless/ath/Kconfig linux-6.1.97/drivers/net/wireless/ath/Kconfig
--- linux-6.1.97.orig/drivers/net/wireless/ath/Kconfig	2024-07-05 09:32:02.000000000 +0200
+++ linux-6.1.97/drivers/net/wireless/ath/Kconfig	2024-07-06 10:37:52.406164727 +0200
@@ -23,6 +23,9 @@
 
 if WLAN_VENDOR_ATH
 
+config ATH_USER_REGD
+	bool "Do not enforce EEPROM regulatory restrictions"
+
 config ATH_DEBUG
 	bool "Atheros wireless debugging"
 	help
diff -uNr linux-6.1.97.orig/drivers/net/wireless/ath/ath.h linux-6.1.97/drivers/net/wireless/ath/ath.h
--- linux-6.1.97.orig/drivers/net/wireless/ath/ath.h	2024-07-05 09:32:02.000000000 +0200
+++ linux-6.1.97/drivers/net/wireless/ath/ath.h	2024-07-06 10:37:52.406164727 +0200
@@ -151,6 +151,7 @@
 	int debug_mask;
 	enum ath_device_state state;
 	unsigned long op_flags;
+	u32 chan_bw;
 
 	struct ath_ani ani;
 
diff -uNr linux-6.1.97.orig/drivers/net/wireless/ath/ath5k/ath5k.h linux-6.1.97/drivers/net/wireless/ath/ath5k/ath5k.h
--- linux-6.1.97.orig/drivers/net/wireless/ath/ath5k/ath5k.h	2024-07-05 09:32:02.000000000 +0200
+++ linux-6.1.97/drivers/net/wireless/ath/ath5k/ath5k.h	2024-07-06 10:37:52.390164304 +0200
@@ -1372,6 +1372,7 @@
 	u8			ah_coverage_class;
 	bool			ah_ack_bitrate_high;
 	u8			ah_bwmode;
+	u8			ah_bwmode_debug;
 	bool			ah_short_slot;
 
 	/* Antenna Control */
diff -uNr linux-6.1.97.orig/drivers/net/wireless/ath/ath5k/base.c linux-6.1.97/drivers/net/wireless/ath/ath5k/base.c
--- linux-6.1.97.orig/drivers/net/wireless/ath/ath5k/base.c	2024-07-05 09:32:02.000000000 +0200
+++ linux-6.1.97/drivers/net/wireless/ath/ath5k/base.c	2024-07-06 10:37:52.406164727 +0200
@@ -465,6 +465,9 @@
 		return -EINVAL;
 	}
 
+	if (ah->ah_bwmode_debug != AR5K_BWMODE_DEFAULT)
+		ah->ah_bwmode = ah->ah_bwmode_debug;
+
 	/*
 	 * To switch channels clear any pending DMA operations;
 	 * wait long enough for the RX fifo to drain, reset the
diff -uNr linux-6.1.97.orig/drivers/net/wireless/ath/ath5k/debug.c linux-6.1.97/drivers/net/wireless/ath/ath5k/debug.c
--- linux-6.1.97.orig/drivers/net/wireless/ath/ath5k/debug.c	2024-07-05 09:32:02.000000000 +0200
+++ linux-6.1.97/drivers/net/wireless/ath/ath5k/debug.c	2024-07-06 10:37:52.406164727 +0200
@@ -803,6 +803,97 @@
 	.llseek = default_llseek,
 };
 
+/* debugfs: bwmode */
+
+static ssize_t read_file_bwmode(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+	struct ath5k_hw *ah = file->private_data;
+	char buf[15];
+	unsigned int len = 0;
+
+	int cur_ah_bwmode = ah->ah_bwmode_debug;
+
+#define print_selected(MODE, LABEL) \
+	if (cur_ah_bwmode == MODE) \
+		len += snprintf(buf+len, sizeof(buf)-len, "[%s]", LABEL); \
+	else \
+		len += snprintf(buf+len, sizeof(buf)-len, "%s", LABEL); \
+	len += snprintf(buf+len, sizeof(buf)-len, " ");
+
+	print_selected(AR5K_BWMODE_5MHZ, "5");
+	print_selected(AR5K_BWMODE_10MHZ, "10");
+	print_selected(AR5K_BWMODE_DEFAULT, "20");
+	print_selected(AR5K_BWMODE_40MHZ, "40");
+#undef print_selected
+
+	len += snprintf(buf+len, sizeof(buf)-len, "\n");
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_bwmode(struct file *file,
+				 const char __user *userbuf,
+				 size_t count, loff_t *ppos)
+{
+	struct ath5k_hw *ah = file->private_data;
+	char buf[3];
+	int bw = 20;
+	int tobwmode = AR5K_BWMODE_DEFAULT;
+
+	if (copy_from_user(buf, userbuf, min(count, sizeof(buf))))
+		return -EFAULT;
+
+	/* TODO: Add check for active interface */
+
+	if(strncmp(buf, "5", 1) == 0 ) {
+		tobwmode = AR5K_BWMODE_5MHZ;
+		bw = 5;
+	} else if ( strncmp(buf, "10", 2) == 0 ) {
+		tobwmode = AR5K_BWMODE_10MHZ;
+		bw = 10;
+	} else if ( strncmp(buf, "20", 2) == 0 ) {
+		tobwmode = AR5K_BWMODE_DEFAULT;
+		bw = 20;
+	} else if ( strncmp(buf, "40", 2) == 0 ) {
+		tobwmode = AR5K_BWMODE_40MHZ;
+		bw = 40;
+	} else
+		return -EINVAL;
+
+	ATH5K_INFO(ah, "Changing to %imhz channel width[%i]\n",
+		bw, tobwmode);
+
+	switch (ah->ah_radio) {
+	/* TODO: only define radios that actually support 5/10mhz channels */
+	case AR5K_RF5413:
+	case AR5K_RF5110:
+	case AR5K_RF5111:
+	case AR5K_RF5112:
+	case AR5K_RF2413:
+	case AR5K_RF2316:
+	case AR5K_RF2317:
+	case AR5K_RF2425:
+		if(ah->ah_bwmode_debug != tobwmode) {
+			mutex_lock(&ah->lock);
+			ah->ah_bwmode = tobwmode;
+			ah->ah_bwmode_debug = tobwmode;
+			mutex_unlock(&ah->lock);
+		}
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+	return count;
+}
+
+static const struct file_operations fops_bwmode = {
+	.read = read_file_bwmode,
+	.write = write_file_bwmode,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
 
 /* debugfs: queues etc */
 
@@ -997,6 +1088,8 @@
 	debugfs_create_file("queue", 0600, phydir, ah, &fops_queue);
 	debugfs_create_bool("32khz_clock", 0600, phydir,
 			    &ah->ah_use_32khz_clock);
+	debugfs_create_file("bwmode", S_IWUSR | S_IRUSR, phydir, ah,
+			    &fops_bwmode);
 }
 
 /* functions used in other places */
diff -uNr linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/ani.h linux-6.1.97/drivers/net/wireless/ath/ath9k/ani.h
--- linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/ani.h	2024-07-05 09:32:02.000000000 +0200
+++ linux-6.1.97/drivers/net/wireless/ath/ath9k/ani.h	2024-07-06 10:37:52.406164727 +0200
@@ -42,7 +42,7 @@
 #define ATH9K_ANI_PERIOD                  300
 
 /* in ms */
-#define ATH9K_ANI_POLLINTERVAL            1000
+#define ATH9K_ANI_POLLINTERVAL            300
 
 #define ATH9K_SIG_FIRSTEP_SETTING_MIN     0
 #define ATH9K_SIG_FIRSTEP_SETTING_MAX     20
diff -uNr linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/ar5008_phy.c linux-6.1.97/drivers/net/wireless/ath/ath9k/ar5008_phy.c
--- linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/ar5008_phy.c	2024-07-05 09:32:02.000000000 +0200
+++ linux-6.1.97/drivers/net/wireless/ath/ath9k/ar5008_phy.c	2024-07-06 10:37:52.406164727 +0200
@@ -969,55 +969,6 @@
 		 * on == 0 means more noise imm
 		 */
 		u32 on = param ? 1 : 0;
-		/*
-		 * make register setting for default
-		 * (weak sig detect ON) come from INI file
-		 */
-		int m1ThreshLow = on ?
-			aniState->iniDef.m1ThreshLow : m1ThreshLow_off;
-		int m2ThreshLow = on ?
-			aniState->iniDef.m2ThreshLow : m2ThreshLow_off;
-		int m1Thresh = on ?
-			aniState->iniDef.m1Thresh : m1Thresh_off;
-		int m2Thresh = on ?
-			aniState->iniDef.m2Thresh : m2Thresh_off;
-		int m2CountThr = on ?
-			aniState->iniDef.m2CountThr : m2CountThr_off;
-		int m2CountThrLow = on ?
-			aniState->iniDef.m2CountThrLow : m2CountThrLow_off;
-		int m1ThreshLowExt = on ?
-			aniState->iniDef.m1ThreshLowExt : m1ThreshLowExt_off;
-		int m2ThreshLowExt = on ?
-			aniState->iniDef.m2ThreshLowExt : m2ThreshLowExt_off;
-		int m1ThreshExt = on ?
-			aniState->iniDef.m1ThreshExt : m1ThreshExt_off;
-		int m2ThreshExt = on ?
-			aniState->iniDef.m2ThreshExt : m2ThreshExt_off;
-
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
-			      AR_PHY_SFCORR_LOW_M1_THRESH_LOW,
-			      m1ThreshLow);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
-			      AR_PHY_SFCORR_LOW_M2_THRESH_LOW,
-			      m2ThreshLow);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
-			      AR_PHY_SFCORR_M1_THRESH, m1Thresh);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
-			      AR_PHY_SFCORR_M2_THRESH, m2Thresh);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
-			      AR_PHY_SFCORR_M2COUNT_THR, m2CountThr);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
-			      AR_PHY_SFCORR_LOW_M2COUNT_THR_LOW,
-			      m2CountThrLow);
-
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M1_THRESH_LOW, m1ThreshLowExt);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M2_THRESH_LOW, m2ThreshLowExt);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M1_THRESH, m1ThreshExt);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M2_THRESH, m2ThreshExt);
 
 		if (on)
 			REG_SET_BIT(ah, AR_PHY_SFCORR_LOW,
diff -uNr linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/ar9003_phy.c linux-6.1.97/drivers/net/wireless/ath/ath9k/ar9003_phy.c
--- linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/ar9003_phy.c	2024-07-05 09:32:02.000000000 +0200
+++ linux-6.1.97/drivers/net/wireless/ath/ath9k/ar9003_phy.c	2024-07-06 10:37:52.406164727 +0200
@@ -42,20 +42,6 @@
 /* level:  0   1   2   3   4   5   6   7   8  */
 	{ -6, -4, -2,  0,  2,  4,  6,  8 };     /* lvl 0-7, default 3 */
 
-/*
- * register values to turn OFDM weak signal detection OFF
- */
-static const int m1ThreshLow_off = 127;
-static const int m2ThreshLow_off = 127;
-static const int m1Thresh_off = 127;
-static const int m2Thresh_off = 127;
-static const int m2CountThr_off =  31;
-static const int m2CountThrLow_off =  63;
-static const int m1ThreshLowExt_off = 127;
-static const int m2ThreshLowExt_off = 127;
-static const int m1ThreshExt_off = 127;
-static const int m2ThreshExt_off = 127;
-
 static const u8 ofdm2pwr[] = {
 	ALL_TARGET_LEGACY_6_24,
 	ALL_TARGET_LEGACY_6_24,
@@ -1068,11 +1054,6 @@
 	struct ath_common *common = ath9k_hw_common(ah);
 	struct ath9k_channel *chan = ah->curchan;
 	struct ar5416AniState *aniState = &ah->ani;
-	int m1ThreshLow, m2ThreshLow;
-	int m1Thresh, m2Thresh;
-	int m2CountThr, m2CountThrLow;
-	int m1ThreshLowExt, m2ThreshLowExt;
-	int m1ThreshExt, m2ThreshExt;
 	s32 value, value2;
 
 	switch (cmd & ah->ani_function) {
@@ -1086,61 +1067,6 @@
 		 */
 		u32 on = param ? 1 : 0;
 
-		if (AR_SREV_9462(ah) || AR_SREV_9565(ah))
-			goto skip_ws_det;
-
-		m1ThreshLow = on ?
-			aniState->iniDef.m1ThreshLow : m1ThreshLow_off;
-		m2ThreshLow = on ?
-			aniState->iniDef.m2ThreshLow : m2ThreshLow_off;
-		m1Thresh = on ?
-			aniState->iniDef.m1Thresh : m1Thresh_off;
-		m2Thresh = on ?
-			aniState->iniDef.m2Thresh : m2Thresh_off;
-		m2CountThr = on ?
-			aniState->iniDef.m2CountThr : m2CountThr_off;
-		m2CountThrLow = on ?
-			aniState->iniDef.m2CountThrLow : m2CountThrLow_off;
-		m1ThreshLowExt = on ?
-			aniState->iniDef.m1ThreshLowExt : m1ThreshLowExt_off;
-		m2ThreshLowExt = on ?
-			aniState->iniDef.m2ThreshLowExt : m2ThreshLowExt_off;
-		m1ThreshExt = on ?
-			aniState->iniDef.m1ThreshExt : m1ThreshExt_off;
-		m2ThreshExt = on ?
-			aniState->iniDef.m2ThreshExt : m2ThreshExt_off;
-
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
-			      AR_PHY_SFCORR_LOW_M1_THRESH_LOW,
-			      m1ThreshLow);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
-			      AR_PHY_SFCORR_LOW_M2_THRESH_LOW,
-			      m2ThreshLow);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
-			      AR_PHY_SFCORR_M1_THRESH,
-			      m1Thresh);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
-			      AR_PHY_SFCORR_M2_THRESH,
-			      m2Thresh);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
-			      AR_PHY_SFCORR_M2COUNT_THR,
-			      m2CountThr);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
-			      AR_PHY_SFCORR_LOW_M2COUNT_THR_LOW,
-			      m2CountThrLow);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M1_THRESH_LOW,
-			      m1ThreshLowExt);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M2_THRESH_LOW,
-			      m2ThreshLowExt);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M1_THRESH,
-			      m1ThreshExt);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M2_THRESH,
-			      m2ThreshExt);
-skip_ws_det:
 		if (on)
 			REG_SET_BIT(ah, AR_PHY_SFCORR_LOW,
 				    AR_PHY_SFCORR_LOW_USE_SELF_CORR_LOW);
diff -uNr linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/ath9k.h linux-6.1.97/drivers/net/wireless/ath/ath9k/ath9k.h
--- linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/ath9k.h	2024-07-05 09:32:02.000000000 +0200
+++ linux-6.1.97/drivers/net/wireless/ath/ath9k/ath9k.h	2024-07-06 10:37:52.406164727 +0200
@@ -88,7 +88,7 @@
 		(_l) &= ((_sz) - 1);		\
 	} while (0)
 
-#define ATH_RXBUF               512
+#define ATH_RXBUF               256
 #define ATH_TXBUF               512
 #define ATH_TXBUF_RESERVE       5
 #define ATH_TXMAXTRY            13
diff -uNr linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/common.c linux-6.1.97/drivers/net/wireless/ath/ath9k/common.c
--- linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/common.c	2024-07-05 09:32:02.000000000 +0200
+++ linux-6.1.97/drivers/net/wireless/ath/ath9k/common.c	2024-07-06 10:37:52.406164727 +0200
@@ -297,11 +297,13 @@
 /*
  * Update internal channel flags.
  */
-static void ath9k_cmn_update_ichannel(struct ath9k_channel *ichan,
+static void ath9k_cmn_update_ichannel(struct ath_common *common,
+				      struct ath9k_channel *ichan,
 				      struct cfg80211_chan_def *chandef)
 {
 	struct ieee80211_channel *chan = chandef->chan;
 	u16 flags = 0;
+	int width;
 
 	ichan->channel = chan->center_freq;
 	ichan->chan = chan;
@@ -309,7 +311,19 @@
 	if (chan->band == NL80211_BAND_5GHZ)
 		flags |= CHANNEL_5GHZ;
 
-	switch (chandef->width) {
+	switch (common->chan_bw) {
+	case 5:
+		width = NL80211_CHAN_WIDTH_5;
+		break;
+	case 10:
+		width = NL80211_CHAN_WIDTH_10;
+		break;
+	default:
+		width = chandef->width;
+		break;
+	}
+
+	switch (width) {
 	case NL80211_CHAN_WIDTH_5:
 		flags |= CHANNEL_QUARTER;
 		break;
@@ -342,10 +356,11 @@
 					    struct cfg80211_chan_def *chandef)
 {
 	struct ieee80211_channel *curchan = chandef->chan;
+	struct ath_common *common = ath9k_hw_common(ah);
 	struct ath9k_channel *channel;
 
 	channel = &ah->channels[curchan->hw_value];
-	ath9k_cmn_update_ichannel(channel, chandef);
+	ath9k_cmn_update_ichannel(common, channel, chandef);
 
 	return channel;
 }
diff -uNr linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/debug.c linux-6.1.97/drivers/net/wireless/ath/ath9k/debug.c
--- linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/debug.c	2024-07-05 09:32:02.000000000 +0200
+++ linux-6.1.97/drivers/net/wireless/ath/ath9k/debug.c	2024-07-06 10:37:52.406164727 +0200
@@ -1413,6 +1413,99 @@
 	ath9k_cmn_spectral_deinit_debug(&sc->spec_priv);
 }
 
+static ssize_t read_file_eeprom(struct file *file, char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_hw *ah = sc->sc_ah;
+	struct ath_common *common = ath9k_hw_common(ah);
+	int bytes = 0;
+	int pos = *ppos;
+	int size = 4096;
+	u16 val;
+	int i;
+
+	if (AR_SREV_9300_20_OR_LATER(ah))
+		size = 16384;
+
+	if (*ppos < 0)
+		return -EINVAL;
+
+	if (count > size - *ppos)
+		count = size - *ppos;
+
+	for (i = *ppos / 2; count > 0; count -= bytes, *ppos += bytes, i++) {
+		void *from = &val;
+
+		if (!common->bus_ops->eeprom_read(common, i, &val))
+			val = 0xffff;
+
+		if (*ppos % 2) {
+			from++;
+			bytes = 1;
+		} else if (count == 1) {
+			bytes = 1;
+		} else {
+			bytes = 2;
+		}
+		copy_to_user(user_buf, from, bytes);
+		user_buf += bytes;
+	}
+	return *ppos - pos;
+}
+
+static const struct file_operations fops_eeprom = {
+	.read = read_file_eeprom,
+	.open = simple_open,
+	.owner = THIS_MODULE
+};
+
+
+static ssize_t read_file_chan_bw(struct file *file, char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	char buf[32];
+	unsigned int len;
+
+	len = sprintf(buf, "0x%08x\n", common->chan_bw);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_chan_bw(struct file *file, const char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	unsigned long chan_bw;
+	char buf[32];
+	ssize_t len;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+	if (kstrtoul(buf, 0, &chan_bw))
+		return -EINVAL;
+
+	common->chan_bw = chan_bw;
+	if (!test_bit(ATH_OP_INVALID, &common->op_flags))
+		ath9k_ops.config(sc->hw, IEEE80211_CONF_CHANGE_CHANNEL);
+
+	return count;
+}
+
+static const struct file_operations fops_chanbw = {
+	.read = read_file_chan_bw,
+	.write = write_file_chan_bw,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+
 int ath9k_init_debug(struct ath_hw *ah)
 {
 	struct ath_common *common = ath9k_hw_common(ah);
@@ -1432,6 +1525,10 @@
 	ath9k_tx99_init_debug(sc);
 	ath9k_cmn_spectral_init_debug(&sc->spec_priv, sc->debug.debugfs_phy);
 
+	debugfs_create_file("eeprom", S_IRUSR, sc->debug.debugfs_phy, sc,
+			    &fops_eeprom);
+	debugfs_create_file("chanbw", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
+			    sc, &fops_chanbw);
 	debugfs_create_devm_seqfile(sc->dev, "dma", sc->debug.debugfs_phy,
 				    read_file_dma);
 	debugfs_create_devm_seqfile(sc->dev, "interrupt", sc->debug.debugfs_phy,
diff -uNr linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/hw.c linux-6.1.97/drivers/net/wireless/ath/ath9k/hw.c
--- linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/hw.c	2024-07-05 09:32:02.000000000 +0200
+++ linux-6.1.97/drivers/net/wireless/ath/ath9k/hw.c	2024-07-06 10:37:52.406164727 +0200
@@ -247,6 +247,19 @@
 		centers->synth_center + (extoff * HT40_CHANNEL_CENTER_SHIFT);
 }
 
+static inline void ath9k_hw_disable_pll_lock_detect(struct ath_hw *ah)
+{
+	/* On AR9330 and AR9340 devices, some PHY registers must be
+	 * tuned to gain better stability/performance. These registers
+	 * might be changed while doing wlan reset so the registers must
+	 * be reprogrammed after each reset.
+	 */
+	REG_CLR_BIT(ah, AR_PHY_USB_CTRL1, BIT(20));
+	REG_RMW(ah, AR_PHY_USB_CTRL2,
+		(1 << 21) | (0xf << 22),
+		(1 << 21) | (0x3 << 22));
+}
+
 /******************/
 /* Chip Revisions */
 /******************/
@@ -402,13 +415,8 @@
 
 	ah->config.rx_intr_mitigation = true;
 
-	if (AR_SREV_9300_20_OR_LATER(ah)) {
-		ah->config.rimt_last = 500;
-		ah->config.rimt_first = 2000;
-	} else {
-		ah->config.rimt_last = 250;
-		ah->config.rimt_first = 700;
-	}
+	ah->config.rimt_last = 250;
+	ah->config.rimt_first = 500;
 
 	if (AR_SREV_9462(ah) || AR_SREV_9565(ah))
 		ah->config.pll_pwrsave = 7;
@@ -667,6 +675,7 @@
 
 	/* These are all the AR5008/AR9001/AR9002/AR9003 hardware family of chipsets */
 	switch (ah->hw_version.devid) {
+	case AR9300_DEVID_INVALID:
 	case AR5416_DEVID_PCI:
 	case AR5416_DEVID_PCIE:
 	case AR5416_AR9100_DEVID:
@@ -1311,39 +1320,56 @@
 	*coef_exponent = coef_exp - 16;
 }
 
-/* AR9330 WAR:
- * call external reset function to reset WMAC if:
- * - doing a cold reset
- * - we have pending frames in the TX queues.
- */
-static bool ath9k_hw_ar9330_reset_war(struct ath_hw *ah, int type)
+static bool ath9k_hw_need_external_reset(struct ath_hw *ah, int type)
 {
-	int i, npend = 0;
+	int i;
 
-	for (i = 0; i < AR_NUM_QCU; i++) {
-		npend = ath9k_hw_numtxpending(ah, i);
-		if (npend)
-			break;
-	}
+	if (type == ATH9K_RESET_COLD)
+		return true;
 
-	if (ah->external_reset &&
-	    (npend || type == ATH9K_RESET_COLD)) {
-		int reset_err = 0;
-
-		ath_dbg(ath9k_hw_common(ah), RESET,
-			"reset MAC via external reset\n");
-
-		reset_err = ah->external_reset();
-		if (reset_err) {
-			ath_err(ath9k_hw_common(ah),
-				"External reset failed, err=%d\n",
-				reset_err);
-			return false;
+	if (AR_SREV_9550(ah))
+		return true;
+
+	/* AR9330 WAR:
+	 * call external reset function to reset WMAC if:
+	 * - doing a cold reset
+	 * - we have pending frames in the TX queues.
+	 */
+	if (AR_SREV_9330(ah)) {
+		for (i = 0; i < AR_NUM_QCU; i++) {
+			if (ath9k_hw_numtxpending(ah, i))
+				return true;
 		}
+	}
+
+	return false;
+}
+
+static bool ath9k_hw_external_reset(struct ath_hw *ah, int type)
+{
+	int err;
+
+	if (!ah->external_reset || !ath9k_hw_need_external_reset(ah, type))
+		return true;
+
+	ath_dbg(ath9k_hw_common(ah), RESET,
+		"reset MAC via external reset\n");
 
-		REG_WRITE(ah, AR_RTC_RESET(ah), 1);
+	err = ah->external_reset();
+	if (err) {
+		ath_err(ath9k_hw_common(ah),
+			"External reset failed, err=%d\n", err);
+		return false;
 	}
 
+	if (AR_SREV_9550(ah)) {
+		REG_WRITE(ah, AR_RTC_RESET(ah), 0);
+		udelay(10);
+	}
+
+	REG_WRITE(ah, AR_RTC_RESET(ah), 1);
+	udelay(10);
+
 	return true;
 }
 
@@ -1396,24 +1422,24 @@
 			rst_flags |= AR_RTC_RC_MAC_COLD;
 	}
 
-	if (AR_SREV_9330(ah)) {
-		if (!ath9k_hw_ar9330_reset_war(ah, type))
-			return false;
-	}
-
 	if (ath9k_hw_mci_is_enabled(ah))
 		ar9003_mci_check_gpm_offset(ah);
 
 	/* DMA HALT added to resolve ar9300 and ar9580 bus error during
-	 * RTC_RC reg read
+	 * RTC_RC reg read. Also needed for AR9550 external reset
 	 */
-	if (AR_SREV_9300(ah) || AR_SREV_9580(ah)) {
+	if (AR_SREV_9300(ah) || AR_SREV_9580(ah) || AR_SREV_9550(ah)) {
 		REG_SET_BIT(ah, AR_CFG, AR_CFG_HALT_REQ);
 		ath9k_hw_wait(ah, AR_CFG, AR_CFG_HALT_ACK, AR_CFG_HALT_ACK,
 			      20 * AH_WAIT_TIMEOUT);
-		REG_CLR_BIT(ah, AR_CFG, AR_CFG_HALT_REQ);
 	}
 
+	if (!AR_SREV_9100(ah))
+		ath9k_hw_external_reset(ah, type);
+
+	if (AR_SREV_9300(ah) || AR_SREV_9580(ah))
+		REG_CLR_BIT(ah, AR_CFG, AR_CFG_HALT_REQ);
+
 	REG_WRITE(ah, AR_RTC_RC(ah), rst_flags);
 
 	REGWRITE_BUFFER_FLUSH(ah);
@@ -1434,8 +1460,15 @@
 	if (!AR_SREV_9100(ah))
 		REG_WRITE(ah, AR_RC, 0);
 
-	if (AR_SREV_9100(ah))
+	if (AR_SREV_9100(ah)) {
+		/* Reset the AHB-WMAC interface */
+		if (ah->external_reset)
+			ah->external_reset();
 		udelay(50);
+	}
+
+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
+		ath9k_hw_disable_pll_lock_detect(ah);
 
 	return true;
 }
@@ -1536,6 +1569,9 @@
 		ar9003_hw_internal_regulator_apply(ah);
 	ath9k_hw_init_pll(ah, chan);
 
+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
+		ath9k_hw_disable_pll_lock_detect(ah);
+
 	return true;
 }
 
@@ -1842,8 +1878,14 @@
 	if (AR_SREV_9271(ah))
 		ar9002_hw_load_ani_reg(ah, chan);
 
+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
+		ath9k_hw_disable_pll_lock_detect(ah);
+
 	return 0;
 fail:
+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
+		ath9k_hw_disable_pll_lock_detect(ah);
+
 	return -EINVAL;
 }
 
@@ -2082,6 +2124,9 @@
 		ath9k_hw_set_radar_params(ah);
 	}
 
+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
+		ath9k_hw_disable_pll_lock_detect(ah);
+
 	return 0;
 }
 EXPORT_SYMBOL(ath9k_hw_reset);
@@ -2956,7 +3001,8 @@
 {
 	struct ath_regulatory *reg = ath9k_hw_regulatory(ah);
 	struct ieee80211_channel *channel;
-	int chan_pwr, new_pwr;
+	int chan_pwr, new_pwr, max_gain;
+	int ant_gain, ant_reduction = 0;
 	u16 ctl = NO_CTL;
 
 	if (!chan)
@@ -2968,9 +3014,18 @@
 	channel = chan->chan;
 	chan_pwr = min_t(int, channel->max_power * 2, MAX_COMBINED_POWER);
 	new_pwr = min_t(int, chan_pwr, reg->power_limit);
+	max_gain = chan_pwr - new_pwr + channel->max_antenna_gain * 2;
+
+	ant_gain = get_antenna_gain(ah, chan);
+	if (ant_gain > max_gain)
+		ant_reduction = ant_gain - max_gain;
+
+	/* FCC allows maximum antenna gain of 3 dBi */
+	if (reg->region == NL80211_DFS_FCC)
+		ant_reduction = max_t(int, ant_reduction - 6, 0);
 
 	ah->eep_ops->set_txpower(ah, chan, ctl,
-				 get_antenna_gain(ah, chan), new_pwr, test);
+				 ant_reduction, new_pwr, test);
 }
 
 void ath9k_hw_set_txpowerlimit(struct ath_hw *ah, u32 limit, bool test)
diff -uNr linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/hw.h linux-6.1.97/drivers/net/wireless/ath/ath9k/hw.h
--- linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/hw.h	2024-07-05 09:32:02.000000000 +0200
+++ linux-6.1.97/drivers/net/wireless/ath/ath9k/hw.h	2024-07-06 10:37:52.406164727 +0200
@@ -36,6 +36,7 @@
 
 #define ATHEROS_VENDOR_ID	0x168c
 
+#define AR9300_DEVID_INVALID	0xabcd
 #define AR5416_DEVID_PCI	0x0023
 #define AR5416_DEVID_PCIE	0x0024
 #define AR9160_DEVID_PCI	0x0027
diff -uNr linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/init.c linux-6.1.97/drivers/net/wireless/ath/ath9k/init.c
--- linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/init.c	2024-07-05 09:32:02.000000000 +0200
+++ linux-6.1.97/drivers/net/wireless/ath/ath9k/init.c	2024-07-06 10:37:52.406164727 +0200
@@ -48,7 +48,7 @@
 module_param_named(nohwcrypt, ath9k_modparam_nohwcrypt, int, 0444);
 MODULE_PARM_DESC(nohwcrypt, "Disable hardware encryption");
 
-int ath9k_led_blink;
+int ath9k_led_blink = 1;
 module_param_named(blink, ath9k_led_blink, int, 0444);
 MODULE_PARM_DESC(blink, "Enable LED blink on activity");
 
@@ -677,6 +677,12 @@
 
 	ath_dbg(common, CONFIG, "parsing configuration from OF node\n");
 
+	if (of_property_read_bool(np, "qca,disable-2ghz"))
+		ah->disable_2ghz = true;
+
+	if (of_property_read_bool(np, "qca,disable-5ghz"))
+		ah->disable_5ghz = true;
+
 	if (of_property_read_bool(np, "qca,no-eeprom")) {
 		/* ath9k-eeprom-<bus>-<id>.bin */
 		scnprintf(eeprom_name, sizeof(eeprom_name),
@@ -882,6 +888,7 @@
 				 BIT(NL80211_IFTYPE_AP) },
 	{ .max = 1,	.types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
 				 BIT(NL80211_IFTYPE_P2P_GO) },
+	{ .max = 1,	.types = BIT(NL80211_IFTYPE_ADHOC) },
 };
 
 #ifdef CONFIG_ATH9K_CHANNEL_CONTEXT
@@ -1179,25 +1186,25 @@
 {
 	int error;
 
-	error = ath_pci_init();
+	error = ath_ahb_init();
 	if (error < 0) {
-		pr_err("No PCI devices found, driver not installed\n");
 		error = -ENODEV;
 		goto err_out;
 	}
 
-	error = ath_ahb_init();
+	error = ath_pci_init();
 	if (error < 0) {
+		pr_err("No PCI devices found, driver not installed\n");
 		error = -ENODEV;
-		goto err_pci_exit;
+		goto err_ahb_exit;
 	}
 
 	dmi_check_system(ath9k_quirks);
 
 	return 0;
 
- err_pci_exit:
-	ath_pci_exit();
+ err_ahb_exit:
+	ath_ahb_exit();
  err_out:
 	return error;
 }
diff -uNr linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/mac.c linux-6.1.97/drivers/net/wireless/ath/ath9k/mac.c
--- linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/mac.c	2024-07-05 09:32:02.000000000 +0200
+++ linux-6.1.97/drivers/net/wireless/ath/ath9k/mac.c	2024-07-06 10:37:52.406164727 +0200
@@ -678,13 +678,18 @@
 
 	ath9k_ani_reset(ah, is_scanning);
 
-	REG_CLR_BIT(ah, AR_DIAG_SW, (AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT));
+	REG_CLR_BIT(ah, AR_DIAG_SW,
+		    AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT | AR_DIAG_FORCE_RX_CLEAR);
 }
 EXPORT_SYMBOL(ath9k_hw_startpcureceive);
 
 void ath9k_hw_abortpcurecv(struct ath_hw *ah)
 {
-	REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_ABORT | AR_DIAG_RX_DIS);
+	u32 reg = AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT;
+
+	if (!IS_ENABLED(CONFIG_ATH9K_TX99))
+		reg |= AR_DIAG_FORCE_RX_CLEAR;
+	REG_SET_BIT(ah, AR_DIAG_SW, reg);
 
 	ath9k_hw_disable_mib_counters(ah);
 }
diff -uNr linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/pci.c linux-6.1.97/drivers/net/wireless/ath/ath9k/pci.c
--- linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/pci.c	2024-07-05 09:32:02.000000000 +0200
+++ linux-6.1.97/drivers/net/wireless/ath/ath9k/pci.c	2024-07-06 10:37:52.406164727 +0200
@@ -774,6 +774,7 @@
 	  .driver_data = ATH9K_PCI_BT_ANT_DIV },
 #endif
 
+	{ PCI_VDEVICE(ATHEROS, 0xabcd) }, /* PCI-E  internal chip default ID */
 	{ 0 }
 };
 
diff -uNr linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/phy.h linux-6.1.97/drivers/net/wireless/ath/ath9k/phy.h
--- linux-6.1.97.orig/drivers/net/wireless/ath/ath9k/phy.h	2024-07-05 09:32:02.000000000 +0200
+++ linux-6.1.97/drivers/net/wireless/ath/ath9k/phy.h	2024-07-06 10:37:52.406164727 +0200
@@ -48,6 +48,9 @@
 #define AR_PHY_PLL_CONTROL 0x16180
 #define AR_PHY_PLL_MODE 0x16184
 
+#define AR_PHY_USB_CTRL1	0x16c84
+#define AR_PHY_USB_CTRL2	0x16c88
+
 enum ath9k_ant_div_comb_lna_conf {
 	ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2,
 	ATH_ANT_DIV_COMB_LNA2,
diff -uNr linux-6.1.97.orig/drivers/net/wireless/ath/regd.c linux-6.1.97/drivers/net/wireless/ath/regd.c
--- linux-6.1.97.orig/drivers/net/wireless/ath/regd.c	2024-07-05 09:32:02.000000000 +0200
+++ linux-6.1.97/drivers/net/wireless/ath/regd.c	2024-07-06 10:37:52.406164727 +0200
@@ -24,6 +24,7 @@
 #include "regd_common.h"
 
 static int __ath_regd_init(struct ath_regulatory *reg);
+static struct reg_dmn_pair_mapping *ath_get_regpair(int regdmn);
 
 /*
  * This is a set of common rules used by our world regulatory domains.
@@ -43,7 +44,8 @@
 					 NL80211_RRF_NO_OFDM)
 
 /* We allow IBSS on these on a case by case basis by regulatory domain */
-#define ATH_5GHZ_5150_5350	REG_RULE(5150-10, 5350+10, 80, 0, 30,\
+#define ATH_5GHZ_5150_5350	REG_RULE(5150-10, 5240+10, 80, 0, 30, 0),\
+				REG_RULE(5260-10, 5350+10, 80, 0, 30,\
 					 NL80211_RRF_NO_IR)
 #define ATH_5GHZ_5470_5850	REG_RULE(5470-10, 5850+10, 80, 0, 30,\
 					 NL80211_RRF_NO_IR)
@@ -61,64 +63,79 @@
 #define ATH_5GHZ_NO_MIDBAND	ATH_5GHZ_5150_5350, \
 				ATH_5GHZ_5725_5850
 
+#define REGD_RULES(...) \
+	.reg_rules = { __VA_ARGS__ }, \
+	.n_reg_rules = ARRAY_SIZE(((struct ieee80211_reg_rule[]) { __VA_ARGS__ }))
+
 /* Can be used for:
  * 0x60, 0x61, 0x62 */
 static const struct ieee80211_regdomain ath_world_regdom_60_61_62 = {
-	.n_reg_rules = 5,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH_2GHZ_ALL,
 		ATH_5GHZ_ALL,
-	}
+	)
 };
 
 /* Can be used by 0x63 and 0x65 */
 static const struct ieee80211_regdomain ath_world_regdom_63_65 = {
-	.n_reg_rules = 4,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH_2GHZ_CH01_11,
 		ATH_2GHZ_CH12_13,
 		ATH_5GHZ_NO_MIDBAND,
-	}
+	)
 };
 
 /* Can be used by 0x64 only */
 static const struct ieee80211_regdomain ath_world_regdom_64 = {
-	.n_reg_rules = 3,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH_2GHZ_CH01_11,
 		ATH_5GHZ_NO_MIDBAND,
-	}
+	)
 };
 
 /* Can be used by 0x66 and 0x69 */
 static const struct ieee80211_regdomain ath_world_regdom_66_69 = {
-	.n_reg_rules = 3,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH_2GHZ_CH01_11,
 		ATH_5GHZ_ALL,
-	}
+	)
 };
 
 /* Can be used by 0x67, 0x68, 0x6A and 0x6C */
 static const struct ieee80211_regdomain ath_world_regdom_67_68_6A_6C = {
-	.n_reg_rules = 4,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH_2GHZ_CH01_11,
 		ATH_2GHZ_CH12_13,
 		ATH_5GHZ_ALL,
-	}
+	)
 };
 
+static u16 ath_regd_get_eepromRD(struct ath_regulatory *reg)
+{
+	return reg->current_rd & ~WORLDWIDE_ROAMING_FLAG;
+}
+
+static bool is_default_regd(struct ath_regulatory *reg)
+{
+	return ath_regd_get_eepromRD(reg) == CTRY_DEFAULT;
+}
+
 static bool dynamic_country_user_possible(struct ath_regulatory *reg)
 {
+	if (IS_ENABLED(CONFIG_ATH_USER_REGD))
+		return true;
+
 	if (IS_ENABLED(CONFIG_ATH_REG_DYNAMIC_USER_CERT_TESTING))
 		return true;
 
+	if (is_default_regd(reg))
+		return true;
+
 	switch (reg->country_code) {
 	case CTRY_UNITED_STATES:
 	case CTRY_JAPAN1:
@@ -188,6 +205,8 @@
 
 static bool ath_reg_dyn_country_user_allow(struct ath_regulatory *reg)
 {
+	if (IS_ENABLED(CONFIG_ATH_USER_REGD))
+		return true;
 	if (!IS_ENABLED(CONFIG_ATH_REG_DYNAMIC_USER_REG_HINTS))
 		return false;
 	if (!dynamic_country_user_possible(reg))
@@ -202,11 +221,6 @@
 		(regd == WORLD));
 }
 
-static u16 ath_regd_get_eepromRD(struct ath_regulatory *reg)
-{
-	return reg->current_rd & ~WORLDWIDE_ROAMING_FLAG;
-}
-
 bool ath_is_world_regd(struct ath_regulatory *reg)
 {
 	return is_wwr_sku(ath_regd_get_eepromRD(reg));
@@ -345,6 +359,9 @@
 	struct ieee80211_channel *ch;
 	unsigned int i;
 
+	if (IS_ENABLED(CONFIG_ATH_USER_REGD))
+		return;
+
 	for (band = 0; band < NUM_NL80211_BANDS; band++) {
 		if (!wiphy->bands[band])
 			continue;
@@ -379,6 +396,9 @@
 {
 	struct ieee80211_supported_band *sband;
 
+	if (IS_ENABLED(CONFIG_ATH_USER_REGD))
+		return;
+
 	sband = wiphy->bands[NL80211_BAND_2GHZ];
 	if (!sband)
 		return;
@@ -408,6 +428,9 @@
 	struct ieee80211_channel *ch;
 	unsigned int i;
 
+	if (IS_ENABLED(CONFIG_ATH_USER_REGD))
+		return;
+
 	if (!wiphy->bands[NL80211_BAND_5GHZ])
 		return;
 
@@ -640,6 +663,13 @@
 	const struct ieee80211_regdomain *regd;
 
 	wiphy->reg_notifier = reg_notifier;
+
+	if (IS_ENABLED(CONFIG_ATH_USER_REGD))
+		return 0;
+
+	if (is_default_regd(reg))
+		return 0;
+
 	wiphy->regulatory_flags |= REGULATORY_STRICT_REG |
 				   REGULATORY_CUSTOM_REG;
 
diff -uNr linux-6.1.97.orig/drivers/net/wireless/ath/regd_common.h linux-6.1.97/drivers/net/wireless/ath/regd_common.h
--- linux-6.1.97.orig/drivers/net/wireless/ath/regd_common.h	2024-07-06 10:37:44.581957853 +0200
+++ linux-6.1.97/drivers/net/wireless/ath/regd_common.h	2024-07-06 10:37:52.406164727 +0200
@@ -32,6 +32,7 @@
 	ETSI1_WORLD = 0x21,
 	FCC2_ETSIC = 0x22,
 	FCC6_WORLD = 0x23,
+	FCC3_FCCA_2 = 0x2A,
 	FRANCE_RES = 0x31,
 	FCC3_FCCA = 0x3A,
 	FCC3_WORLD = 0x3B,
@@ -173,6 +174,7 @@
 	{FCC2_WORLD, CTL_FCC, CTL_ETSI},
 	{FCC2_ETSIC, CTL_FCC, CTL_ETSI},
 	{FCC3_FCCA, CTL_FCC, CTL_FCC},
+	{FCC3_FCCA_2, CTL_FCC, CTL_FCC},
 	{FCC3_WORLD, CTL_FCC, CTL_ETSI},
 	{FCC3_ETSIC, CTL_FCC, CTL_ETSI},
 	{FCC4_FCCA, CTL_FCC, CTL_FCC},
@@ -488,6 +490,7 @@
 	{CTRY_UNITED_STATES, FCC3_FCCA, "US"},
 	{CTRY_UNITED_STATES2, FCC3_FCCA, "US"},
 	{CTRY_UNITED_STATES3, FCC3_FCCA, "US"},
+	{CTRY_UNITED_STATES, FCC3_FCCA_2, "US"},
 	/* This "PS" is for US public safety actually... to support this we
 	 * would need to assign new special alpha2 to CRDA db as with the world
 	 * regdomain and use another alpha2 */
diff -uNr linux-6.1.97.orig/net/wireless/reg.c linux-6.1.97/net/wireless/reg.c
--- linux-6.1.97.orig/net/wireless/reg.c	2024-07-05 09:32:02.000000000 +0200
+++ linux-6.1.97/net/wireless/reg.c	2024-07-06 10:37:52.406164727 +0200
@@ -3372,6 +3372,8 @@
 	enum environment_cap env = ENVIRON_ANY;
 	struct regulatory_request *request = NULL, *lr;
 
+	return;
+
 	/* IE len must be evenly divisible by 2 */
 	if (country_ie_len & 0x01)
 		return;
@@ -3650,6 +3652,7 @@
 		return;
 	}
 
+	return;
 	pr_debug("All devices are disconnected, going to restore regulatory settings\n");
 	restore_regulatory_settings(false, true);
 }
